/* Lesson 8 Task 2. Не выполняя кода, ответить, что выведет браузер и почему:

1.
 if (!("a" in window)) {
    var a = 1;
}
alert(a);

2.
var b = function a(x) {
    x && a(--x);
};
alert(a);

3.
function a(x) {
    return x * 2;
}
var a;
alert(a);

4.
function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);

5.
function a() {
    alert(this);
}
a.call(null);
*/

/*1.
Если а нет в window, то присвоить значение 1
*/

if (!("a" in window)) {
    var a = 1;
}
alert(a);

// Выдаст undefined, получается, что в window у нас нет никакого а...


/*
2.
 */
 
 
var b = function a(x) {
    x && a(--x);
};
alert(a);

// Браузер выдает a is not defined
// Получается мы хотим обратиться к результату функции, но она не опеределенна...



/*3.
	
 */
function a(x) {
    return x * 2;
}
var a;
alert(a);

// alert(а) вернет нам функцию function a(x) {
//    return x * 2;
// }
// Если посмотреть console.log(typeof a), То возвращаемый тип функция, это означает, что у нас при объявлении переменной а, происходит ссылка на уже функцию а, которая есть в памяти

/* 4
Объект arguments является локальной переменной, которая доступна во всех функциях,
 за исключением стрелочных, она позволяет ссылаться внутри функции на аргументы функции с помощью объекта arguments. 
 Этот объект содержит запись для каждого аргумента, переданного в функцию,
 индекс первой записи начинается с 0 и соответствует первому аргументу функции,
 индекс 1 соответствует второму аргументу функции и так далее. 
 Например,
 
 function f( a, b, c) {
	arguments[0]; // соответствует первому аргументу функции
	arguments[1]; // соответствует второму аргументу функции
	arguments[2]; // соответствует третьему аргументу функции
}
Отсюда делаем вывод, что аргумент [2], равено третьему аргументу функции, а именно, значению a  присваивается 10

 */
function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);

//вывод = 10

/* 5.
Синтаксис метода call:
func.call(context, arg1, arg2, ...)
При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть».


Первый аргумент для Function.prototype.call - это контекст, 
который определяет значение this для контекста выполнения вызываемой функции, и ничего больше.
 */
 
 function a() {
    alert(this);
}
a.call(null);

// В данном случае получается мы указываем на месте this null,
// В документации написанно, что если метод является функцией в коде нестрогого режима,
 // значения null и undefined будут заменены глобальным объектом, 
 //поэтому нам возвращается объект окна, object Windows
 // Дело в том что на протяжении долгого времени JavaScript развивался без проблем с обратной совместимостью.
// Новые функции добавлялись в язык, в то время как старая функциональность не менялась.
//Преимуществом данного подхода было то, что существующий код продолжал работать.
// А недостатком – что любая ошибка или несовершенное решение, принятое создателями JavaScript, застревали в языке навсегда.
//Так было до 2009 года, когда появился ECMAScript 5 (ES5). 
//Он добавил новые возможности в язык и изменил некоторые из существующих. 
//Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. 
//Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".
// в strict mode как я понимаю должно же будет вернуть  null.